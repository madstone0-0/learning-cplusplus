#include <MLinalg.hpp>
#include <boost/rational.hpp>
#include <iostream>

#include "Structures.hpp"

using boost::rational;
using namespace std;
using namespace mlinalg::structures;

int main() {
    {
        auto e1 = Vector<double, 2>{1, 0};
        auto e2 = Vector<double, 2>{0, 1};
        auto A = Matrix<double, 3, 3>{{1, -2, 1}, {0, 2, -8}, {5, 0, -5}};
        auto b = Vector<double, 3>{1, 0, -1};
        cout << "Vectors\n\n";
        cout << e1 + e2 << '\n';
        cout << e2 + e1 << '\n';
        cout << A << '\n';
        cout << (A * b).T() << '\n';
        cout << e1.T() * e2 << '\n';
        cout << e1 * e2 << '\n';
        cout << e2 - e1 << '\n';
        cout << e1.T() << '\n';
        cout << e2.T() << '\n';
        e1 = e2.T();
        cout << e1 << '\n';
        cout << e1.dist(e2) << '\n';
        cout << e1.dot(e1) << '\n';
        cout << (e1.T() * e1).at(0) << '\n';
    }
    {
        cout << "\nMatrices\n\n";
        auto A = Matrix<rational<int>, 2, 2>{{5, 1}, {3, -2}};
        auto B = Matrix<rational<int>, 2, 2>{{2, 0}, {4, 3}};
        cout << A << '\n';
        cout << A * B << '\n';
        cout << mlinalg::I<double, 2>() << '\n';
        cout << mlinalg::rref(A) << '\n';
        auto Aaug = A.augment(mlinalg::I<rational<int>, 2>());
        cout << Aaug << '\n';
        cout << mlinalg::rref(Aaug) << '\n';
        auto AInv = mlinalg::inverse(A);
        auto BInv = mlinalg::inverse(B);
        cout << (AInv.has_value() ? string{AInv.value()} : "No Inverse") << '\n';
        cout << (BInv.has_value() ? string{BInv.value()} : "No Inverse") << '\n';
        if (auto AInvInv = mlinalg::inverse(AInv.value()); AInv.has_value() && AInvInv.has_value()) {
            cout << AInvInv.value() << '\n';
        }
        {
            auto A = Matrix<double, 2, 2>{{5, 1}, {3, -2}};
            auto B = Matrix<double, 2, 2>{{2, 0}, {4, 3}};
            cout << A << '\n';
            cout << A * B << '\n';
            cout << mlinalg::I<double, 2>() << '\n';
            cout << mlinalg::rref(A) << '\n';
            auto Aaug = A.augment(mlinalg::I<double, 2>());
            cout << Aaug << '\n';
            cout << mlinalg::rref(Aaug) << '\n';
            auto AInv = mlinalg::inverse(A);
            auto BInv = mlinalg::inverse(B);
            cout << (AInv.has_value() ? string{AInv.value()} : "No Inverse") << '\n';
            cout << (BInv.has_value() ? string{BInv.value()} : "No Inverse") << '\n';
            if (auto AInvInv = mlinalg::inverse(AInv.value()); AInv.has_value() && AInvInv.has_value()) {
                cout << AInvInv.value() << '\n';
            }
        }
        {
            auto A = Matrix<rational<int>, 2, 2>{{5, 1}, {3, -2}};
            auto AT = mlinalg::structures::helpers::extractMatrixFromTranspose(A.T());
            auto ATInv = mlinalg::inverse(AT);
            auto AInvT = mlinalg::inverse(A).value().T();
            if (auto ATInvVal = ATInv.value(); ATInv.has_value()) {
                cout << "(A^T)^{-1}:\n" << ATInvVal << '\n';
                cout << "(A^{-1})^T:\n" << AInvT << '\n';
            }
        }
        {
            auto A = Matrix<double, 3, 3>{{1, 5, 0}, {2, 4, -1}, {0, -2, 0}};
            cout << A.det() << '\n';
            cout << A << '\n';
            auto AInv = mlinalg::inverse(A).value();
            cout << AInv << '\n';
            cout << mlinalg::inverse(AInv).value() << '\n';
        }
        {
            auto A = Matrix<double, 5, 5>{
                {3, -7, 8, 9, -6},  //
                {0, 2, -5, 7, 3},   //
                {0, 0, 1, 5, 0},    //
                {0, 0, 2, 4, -1},   //
                {0, 0, 0, -2, 0}    //
            };
            cout << A << '\n';
            cout << A.det() << '\n';
        }
        {
            auto largeValues = Matrix<double, 5, 5>{{1e6, 1e6, 1e6, 1e6, 1e6},
                                                    {1e6, 1e6, 1e6, 1e6, 1e6},
                                                    {1e6, 1e6, 1e6, 1e6, 1e6},
                                                    {1e6, 1e6, 1e6, 1e6, 1e6},
                                                    {1e6, 1e6, 1e6, 1e6, 1e6}};
            cout << mlinalg::ref(largeValues) << '\n';
            auto random10x10 = Matrix<rational<long>, 10, 10>{{3, -4, 7, -2, 10, -5, -9, 6, -3, 8},  //
                                                              {1, 2, -3, 4, -7, 5, -1, 9, 10, -6},   //
                                                              {7, -8, 2, -9, 5, -4, 6, -3, 8, 0},    //
                                                              {-6, 1, 3, 7, -2, 8, -5, 9, -1, 4},    //
                                                              {2, 9, -1, 6, -3, 0, 8, 5, -7, 1},     //
                                                              {-5, -7, 8, 4, -2, 10, -6, 3, 9, 2},   //
                                                              {0, 6, -4, 1, 8, -3, 7, -2, 4, -9},    //
                                                              {-2, -3, 1, 7, 4, -6, 2, 8, -1, 5},    //
                                                              {3, 4, -8, -5, -1, 10, -7, 6, 2, 9},   //
                                                              {7, 2, 6, -4, 10, -1, 5, 0, -3, 8}};
            cout << mlinalg::rref(random10x10) << '\n';
            auto diagonal15x15 =
                Matrix<double, 15, 15>{{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 7.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 8.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 9.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 11.0, 0.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12.0, 0.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 13.0, 0.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 14.0, 0.0},
                                       {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 15.0}};
            cout << diagonal15x15.det() << '\n';
            auto identity20x20 = Matrix<double, 20, 20>{
                {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
                {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
            cout << identity20x20.det() << '\n';
        }
    }
    return 0;
}
